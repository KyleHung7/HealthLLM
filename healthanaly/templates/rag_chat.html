<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¡€å£“è¡€ç³–å³æ™‚è©¢å•</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/aos@2.3.4/dist/aos.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap" rel="stylesheet">
    <link href="/static/css/navbar.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background: #f0f4f8;
            color: #333;
            padding: 2rem;
            /* font-size: 1.25rem; */
        }
        header {
            background: #a3d5d3;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            text-align: center;
            margin-bottom: 2rem;
        }
        header h1 {
            font-size: 2.5rem;
            color: #064f40;
        }
        .section {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
            margin-bottom: 1.5rem;
        }
        .chat-container {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 1rem;
        }
        .message {
            margin: 0.5rem;
            padding: 0.75rem;
            border-radius: 8px;
        }
        .user-message {
            background-color: #e6f3ff;
            align-self: flex-end;
        }
        .bot-message {
            background-color: #f0f0f0;
            align-self: flex-start;
        }
        .btn-primary {
            background-color: #2c7a7b;
            border: none;
            font-size: 1.25rem;
            padding: 0.75rem 1.5rem;
        }
        .btn-primary:hover {
            background-color: #205e60;
        }
        .btn-active {
            background-color: #205e60 !important;
        }
        #loading {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
        }
        .pulse-loader {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .pulse-circle {
            width: 20px;
            height: 20px;
            background-color: #2c7a7b;
            border-radius: 50%;
            margin: 0 5px;
            animation: pulse 1.2s ease-in-out infinite;
        }
        .pulse-circle:nth-child(2) {
            animation-delay: 0.4s;
        }
        .pulse-circle:nth-child(3) {
            animation-delay: 0.8s;
        }
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 0.7;
            }
            50% {
                transform: scale(1.5);
                opacity: 1;
            }
        }
        /* Responsive adjustments */
        @media (max-width: 768px) {
            body {
                padding: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <!-- <header data-aos="fade-down">
        <h1>ğŸ©º è¡€å£“è¡€ç³–å³æ™‚è©¢å•</h1>
        <p>ç”¨ç§‘æŠ€å®ˆè­·æ‚¨çš„å¥åº· ğŸ’–</p>
    </header> -->

    {% include "partials/navbar.html" %}

    <div class="container">
        <div class="section" data-aos="fade-up">
            <h2 class="h4 mb-4 text-teal">ğŸ’¬ å¥åº·å•é¡Œå³æ™‚å•ç­”</h2>
            <div class="chat-container" id="chat-container"></div>
            <form id="question-form" class="d-flex align-items-center gap-3">
                <input id="question-input" type="text" class="form-control p-3 fs-5" placeholder="è¼¸å…¥æˆ–éŒ„éŸ³å•é¡Œï¼ˆä¾‹å¦‚ï¼šå¦‚ä½•æ§åˆ¶è¡€å£“ï¼Ÿï¼‰">
                <button type="submit" class="btn btn-primary" id="submit-btn">é€å‡º</button>
            </form>
            <div class="mt-3">
                <button id="transcribe-btn" class="btn btn-primary me-2">èªéŸ³è½‰æ–‡å­—</button>
                <button id="voice-btn" class="btn btn-primary btn-active">èªéŸ³å°è«‡</button>
            </div>
            <div class="form-check mt-3">
                <input type="checkbox" class="form-check-input" id="voice-mode" name="voice_mode">
                <label class="form-check-label fs-5" for="voice-mode">æ–‡å­—æäº¤èªéŸ³å›æ‡‰ï¼ˆå¯å‹¾é¸ï¼‰</label>
            </div>
        </div>
    </div>

    <div id="loading">
        <div class="pulse-loader">
            <div class="pulse-circle"></div>
            <div class="pulse-circle"></div>
            <div class="pulse-circle"></div>
        </div>
    </div>

    <audio id="audio-player" class="d-none"></audio>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aos@2.3.4/dist/aos.js"></script>
    <script>
        AOS.init({ duration: 1000, once: true });

        const questionForm = document.getElementById('question-form');
        const questionInput = document.getElementById('question-input');
        const submitBtn = document.getElementById('submit-btn');
        const chatContainer = document.getElementById('chat-container');
        const audioPlayer = document.getElementById('audio-player');
        const voiceMode = document.getElementById('voice-mode');
        const transcribeBtn = document.getElementById('transcribe-btn');
        const voiceBtn = document.getElementById('voice-btn');
        const loading = document.getElementById('loading');
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        let currentMode = 'voice'; // Default to voice mode
        let recordingStartTime = 0; // Track recording start time
        const MIN_RECORDING_TIME = 1000; // 1 second
        const MAX_RECORDING_TIME = 10000; // 10 seconds

        function showLoading() {
            loading.style.display = 'flex';
        }

        function hideLoading() {
            loading.style.display = 'none';
        }

        function getSupportedMimeType() {
            const mimeTypes = ['audio/webm', 'audio/mp4', 'audio/ogg'];
            for (const mimeType of mimeTypes) {
                if (MediaRecorder.isTypeSupported(mimeType)) {
                    console.log(`Supported MIME type: ${mimeType}`);
                    return mimeType;
                }
            }
            console.error('No supported MIME types found');
            return null;
        }

        async function checkMicrophonePermission() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                stream.getTracks().forEach(track => track.stop());
                console.log('Microphone permission granted');
                return true;
            } catch (e) {
                console.error(`Microphone permission error: ${e.message}`);
                return false;
            }
        }

        async function startRecording() {
            if (isRecording) return;
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error("ç€è¦½å™¨ä¸æ”¯æ´éŸ³è¨ŠéŒ„è£½åŠŸèƒ½ï¼Œè«‹ä½¿ç”¨æœ€æ–°ç‰ˆæœ¬çš„ Chromeã€Edge æˆ– Firefox");
                }

                const hasPermission = await checkMicrophonePermission();
                if (!hasPermission) {
                    throw new Error("è«‹å…è¨±ç€è¦½å™¨å­˜å–éº¥å…‹é¢¨ï¼Œæª¢æŸ¥ç€è¦½å™¨è¨­å®šæˆ–é‡æ–°é»æ“ŠæŒ‰éˆ•");
                }

                const mimeType = getSupportedMimeType();
                if (!mimeType) {
                    throw new Error("ç€è¦½å™¨ä¸æ”¯æ´ä»»ä½•éŸ³è¨ŠéŒ„è£½æ ¼å¼ï¼Œè«‹å˜—è©¦æ›´æ–°ç€è¦½å™¨");
                }

                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream, { mimeType });
                audioChunks = [];
                recordingStartTime = Date.now(); // Record start time

                mediaRecorder.ondataavailable = e => {
                    if (e.data.size > 0) {
                        audioChunks.push(e.data);
                        console.log(`Received audio chunk, size: ${e.data.size}, total chunks: ${audioChunks.length}`);
                    } else {
                        console.warn('Empty audio chunk received');
                    }
                };
                mediaRecorder.onstop = () => {
                    stream.getTracks().forEach(track => track.stop());
                    console.log(`Recording stopped, duration: ${(Date.now() - recordingStartTime) / 1000}s, audio chunks: ${audioChunks.length}`);
                };

                mediaRecorder.start(50); // Collect data every 50ms for better granularity
                isRecording = true;
                submitBtn.classList.add('bg-danger');
                submitBtn.innerHTML = 'â¹ï¸ åœæ­¢';
                showLoading();
                console.log(`Recording started, MIME type: ${mimeType}`);
            } catch (e) {
                addMessage('ç³»çµ±', `éŒ„éŸ³å¤±æ•—ï¼š${e.message}`, 'bot-message');
                hideLoading();
            }
        }

        function stopRecording() {
            if (isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                submitBtn.classList.remove('bg-danger');
                submitBtn.innerHTML = 'é€å‡º';
            }
        }

        async function processRecording(mimeType) {
            console.log(`Processing recording, audio chunks: ${audioChunks.length}`);
            if (audioChunks.length === 0) {
                addMessage('ç³»çµ±', 'éŒ„éŸ³å¤±æ•—ï¼šç„¡éŸ³è¨Šæ•¸æ“šï¼Œè«‹ç¢ºèªéº¥å…‹é¢¨æ­£å¸¸ä¸¦å·²æˆäºˆæ¬Šé™', 'bot-message');
                hideLoading();
                return;
            }

            const extension = mimeType.includes('webm') ? '.webm' : mimeType.includes('mp4') ? '.mp4' : '.ogg';
            const audioBlob = new Blob(audioChunks, { type: mimeType });
            const formData = new FormData();
            formData.append('audio', audioBlob, `recording${extension}`);
            formData.append('mode', currentMode);

            try {
                const response = await fetch('/rag_record', { // Changed endpoint
                    method: 'POST',
                    body: formData
                });
                const result = await response.json();

                if (result.error) {
                    addMessage('ç³»çµ±', result.error, 'bot-message');
                } else {
                    if (currentMode === 'transcribe') {
                        questionInput.value = result.transcription; // Only fill input box
                    } else if (currentMode === 'voice') {
                        addMessage('ä½ ', result.transcription, 'user-message');
                        addMessage('ç³»çµ±', result.answer, 'bot-message');
                        if (result.audio) { // Always play audio for voice mode
                            audioPlayer.src = result.audio;
                            audioPlayer.play();
                        }
                    }
                }
            } catch (e) {
                addMessage('ç³»çµ±', `è™•ç†å¤±æ•—ï¼š${e.message}`, 'bot-message');
            }
            hideLoading();
        }

        transcribeBtn.addEventListener('click', async () => {
            currentMode = 'transcribe';
            transcribeBtn.classList.add('btn-active');
            voiceBtn.classList.remove('btn-active');
            await startRecording();
        });

        voiceBtn.addEventListener('click', async () => {
            currentMode = 'voice';
            voiceBtn.classList.add('btn-active');
            transcribeBtn.classList.remove('btn-active');
            await startRecording();
        });

        questionForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            if (isRecording) {
                // Ensure minimum recording time
                const recordingTime = Date.now() - recordingStartTime;
                if (recordingTime < MIN_RECORDING_TIME) {
                    addMessage('ç³»çµ±', `éŒ„éŸ³æ™‚é–“éçŸ­ï¼Œè«‹è‡³å°‘éŒ„éŸ³ ${MIN_RECORDING_TIME / 1000} ç§’`, 'bot-message');
                    stopRecording();
                    hideLoading();
                    return;
                }

                stopRecording();
                const mimeType = mediaRecorder ? mediaRecorder.mimeType : getSupportedMimeType();
                if (mimeType) await processRecording(mimeType);
            } else {
                const question = questionInput.value.trim();
                if (!question) {
                    addMessage('ç³»çµ±', 'è«‹è¼¸å…¥æˆ–éŒ„éŸ³å•é¡Œã€‚', 'bot-message');
                    return;
                }

                showLoading();
                addMessage('ä½ ', question, 'user-message');
                const formData = new FormData();
                formData.append('question', question);
                formData.append('voice_mode', voiceMode.checked);

                try {
                    const response = await fetch('/rag_submit', { // Changed endpoint
                        method: 'POST',
                        body: formData
                    });
                    const result = await response.json();

                    if (result.error) {
                        addMessage('ç³»çµ±', result.error, 'bot-message');
                    } else {
                        addMessage('ç³»çµ±', result.answer, 'bot-message');
                        if (result.audio && voiceMode.checked) {
                            audioPlayer.src = result.audio;
                            audioPlayer.play();
                        }
                    }
                } catch (e) {
                    addMessage('ç³»çµ±', `è™•ç†å¤±æ•—ï¼š${e.message}`, 'bot-message');
                }
                questionInput.value = '';
                hideLoading();
            }
        });

        function addMessage(sender, text, className) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${className} p-3 rounded fs-5`;
            messageDiv.innerHTML = `<strong>${sender}ï¼š</strong> ${text}`;
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }
    </script>
</body>
</html>
